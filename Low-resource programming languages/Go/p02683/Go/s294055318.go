package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	sc := NewScanner(os.Stdin)
	n, m, x := sc.Int(), sc.Int(), sc.Int()
	c := make([]int, n)
	a := make([][]int, n)

	for i := 0; i < n; i++ {
		c[i] = sc.Int()
		a[i] = sc.Ints(m)
	}

	min := 1 << 29
	overX := false

	for bit := 0; bit < (1 << n); bit++ {
		val := 0
		exp := make([]int, m)

		for i := 0; i < n; i++ {
			if bit&(1<<i) != 0 {
				val += c[i]
				for j, ex := range a[i] {
					exp[j] += ex
				}
			}
		}

		skip := false
		for _, ex := range exp {
			if ex < x {
				skip = true
				break
			}
		}
		if skip {
			continue
		}

		overX = true
		min = Min(min, val)
	}

	if !overX {
		fmt.Println(-1)
		return
	}
	fmt.Println(min)
}

// generated by https://github.com/murosan/gollect

func ParseInt(b []byte) (n int) {
	var i int
	if b[0] == '-' {
		i++
	}
	for ; i < len(b); i++ {
		n *= 10
		n += int(b[i] - '0')
	}
	if b[0] == '-' {
		return -n
	}
	return
}

func Min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

type Scanner struct {
	r     io.Reader
	buf   []byte
	delim byte
	size, eof,
	start, end int
}

func NewScanner(r io.Reader) *Scanner { return NewScannerSize(r, 4096) }
func NewScannerSize(r io.Reader, size int) *Scanner {
	return &Scanner{
		r:     r,
		buf:   make([]byte, size),
		delim: ' ',
		size:  size, start: size, end: size,
	}
}

func (s *Scanner) Int() int { return ParseInt(s.bytes()) }

func (s *Scanner) Ints(len int) []int {
	a := make([]int, len)
	for i := 0; i < len; i++ {
		a[i] = s.Int()
	}
	return a
}

func (s *Scanner) bytes() []byte { b, _ := s.next(); return b }
func (s *Scanner) next() (b []byte, size int) {
	for n := 0; ; {
		for i := s.end; i < s.size; i++ {
			if s.buf[i] == s.delim || s.buf[i] == '\n' || i == s.eof {
				b, size = s.buf[s.start:i], i-s.start
				s.start, s.end = i+1, i+1
				return
			}
		}
		s.end = s.size
		if n++; n == 2 {
			panic("lack of buffer size")
		}
		s.read()
	}
}
func (s *Scanner) read() {
	copy(s.buf, s.buf[s.start:s.end])
	s.end -= s.start
	s.start = 0
	n, _ := s.r.Read(s.buf[s.end:])
	s.eof = s.end + n
}
